module FuzzTests exposing
    ( addOneTestControlledFuzz
    , addOneTests
    , addTests
    , addTestsFrequency
    , addTestsTuple
    , arrayGetTests
    , flipTests
    , listLengthTests
    , listReverseTests
    , multiplyFloatTests
    , pizzaLeftTests
    , rippleCarryAdderProperty1
    , rippleCarryAdderProperty2
    , rippleCarryAdderProperty3
    , rippleCarryAdderProperty4
    , stringTests
    , sumListTests
    )

import Array
import Expect exposing (Expectation, FloatingPointTolerance(..))
import Fuzz exposing (..)
import List exposing (repeat)
import MyList exposing (MyList(..), convertToMyList)
import Random exposing (maxInt, minInt)
import RippleCarryAdder exposing (digits, numberFromDigits, rippleCarryAdder)
import Test exposing (..)



{-
   A fuzz test runs the code under test over and over with randomly generated inputs.

   The fuzz function creates a fuzz test: It takes three arguments: a fuzzer that knows how to generate random values, a
   test description, and an anonymous function that contains the actual test.
   A fuzzer in Elm is something that knows how to generate random values of a given type.
   The fuzz module provides a fuzzer for commonly used built-in types. We can also create a fuzzer for custom type of our
   own.
   Unlike unit tests, a fuzz test uses an actual parameter in the lambda function (e.g. num in below case), because it is
   expected to use the parameter inside the lambda.

    fuzz: Fuzzer a -> String -> (a -> Expectation) -> Test
    test:             String -> (() -> Expectation) -> Test

    # Reproducing a Test Result

    elm-test uses a Random number generator (RNG) to create random value for each fuzzer. An RNG takes an initial value
    called seed and uses an algorithm to generate a seemingly random number. Given an initial seed, we can always predict
    the values generated by an RNG, which means fuzz tests are deterministic if we know the initial seed. So if we need
    to reproduce the results from a specific run of a fuzz test, we can run the elm-test command with the --seed option.
    The --fuzz option specifies how many times a fuzz test should run.

    When a fuzz tests fails, instead of showing us the first value the test failed on, it tries to shrink the failing input
    to the smallest and simplest value possible.
-}


addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz int "adds 1 to any integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]


addOne : Int -> Int
addOne x =
    1 + x



{-
   # Property based testing
   While a unit test is focused on verifying one specific input scenario works correctly, a fuzz test on the other hand,
   is focused on making sure an important property holds true for all inputs and outputs.

   Compared to unit tests, fuzz tests make it possible to test the behavior of our code on a much higher level. Instead
   of coming up with individual input scenarios, we can think of properties that must hold true of our code and then write
   fuzz tests to make sure that those properties do hold true. Because of this, writing fuzz tests could turn out to be
   much more challenging than writing individual unit tests especially if our code is complex. We have to think very
   carefully about the exact properties our code exhibits.

   We should always prefer fuzz tests to unit tests, because they give us the most bang for our buck. If we come across
   edge cases that aren't covered by fuzz tests then it's okay to supplement our test suite with unit tests. Otherwise,
   if a unit test isn't providing additional value, we should just delete it.

   # Multiple Fuzzers
   The fuzz2 function is also defined in the Test module and works just like fuzz. The only difference is that it takes
   two fuzzers. Here's how it's type signature looks:

   fuzz2 : Fuzzer a -> Fuzzer b -> String -> (a -> b -> Expectation) -> Test

   If we need three random inputs, we can use fuzz3:

   fuzz3: Fuzzer a -> Fuzzer b -> Fuzzer c -> String -> (a -> b -> c -> Expectation) Test
-}


add : Int -> Int -> Int
add x y =
    x + y


addTests : Test
addTests =
    describe "add"
        [ fuzz2 int int "adds two given integers" <|
            \num1 num2 ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]



{-
   # Controlling Fuzz test runs

   We can control how many times a test runs by using the fuzzWith option, which is also defined in the Test module.

   fuzzWith : FuzzOptions -> Fuzzer a -> String -> (a -> Expectation) -> Test

   type alias FuzzOptions = {runs: Int}

   # Controlling the range of values

   By default, the int fuzzer generates values between -50 and 50. We can control that by using intRange.
-}


addOneTestControlledFuzz : Test
addOneTestControlledFuzz =
    describe "addOne controlled fuzz"
        [ fuzzWith { runs = 200, distribution = noDistribution } int "add 1 to the given integer" <|
            \num ->
                addOne num
                    |> Expect.equal (num + 1)
        , fuzz (intRange minInt maxInt) "adds 1 to the given integer" <|
            \num ->
                addOne num
                    |> Expect.equal (num + 1)
        ]



{-
   # Controlling the Frequency of Values

    We can use the frequency fuzzer to assign the frequency distribution of values to be generated.
    Here is how it's type signature looks:

    frequency: List (Float, Fuzzer a) -> Fuzzer a

    It takes a list of tuples as it's only argument. The first element of that tuple represents a probabilistic weight
    and the second element represents an actual fuzzer responsible for generating random values. The constant fuzzer
    always generates the given value no matter what.

    frequency isn't guaranteed to generate a valid fuzzer. If any of the following conditions is met, it'll return an
    invalid fuzzer in which case the test simply fails:
        * The list of frequencies is empty.
        * Any one of the weights is less than 0.
        * The sum of all weights is 0.
-}


frequencyFuzzer : Fuzzer Int
frequencyFuzzer =
    frequency
        [ ( 70, constant 7 )
        , ( 12, intRange 8 9 )
        , ( 6, constant 6 )
        , ( 9, intRange 2 4 )
        , ( 1, constant 5 )
        , ( 1, constant 1 )
        , ( 1, constant 10 )
        ]


addTestsFrequency : Test
addTestsFrequency =
    describe "addOne Frequency"
        [ fuzz frequencyFuzzer "adds 1 to the given integer" <|
            \num ->
                addOne num
                    |> Expect.equal (num + 1)
        ]


flip : Bool -> Bool
flip x =
    not x


flipTests : Test
flipTests =
    describe "flip"
        [ fuzz bool "negates the given boolean value" <|
            \value ->
                flip value |> Expect.equal (not value)
        ]


multiplyFloat : Float -> Int -> Float
multiplyFloat x y =
    x * toFloat y



{-
   Floating point arithmetic by its nature, is tricky and may introduce minor inaccuracies. Therefore, we should use  the
   Expect.within function, which is better suited for verifying calculations involving floats.

   Expect.within: FloatingPointTolerance -> Float -> Float -> Expectation

   FloatingPointTolerance: A type to describe how close a floating point number must be to the expected value for the
   test to pass.
   Expect.within can only be used with floats.

   The FloatingPointTolerance type is defined like this:

   type FloatingPointTolerance
        = Absolute Float
        | Relative Float
        | AbsoluteOrRelative Float Float


   By using Absolute 0.000000001 in multiplyFloatTests, we're telling elm-test to pass the test as long as the actual
   value is within 0.000000001 of the expected value.
-}


multiplyFloatTests : Test
multiplyFloatTests =
    describe "multiplyFloat"
        [ fuzz2 (floatRange -1.0 1.0) (intRange minInt maxInt) "multiplies given numbers" <|
            \x y ->
                multiplyFloat x y
                    |> Expect.within (Absolute 0.000000001) (x * toFloat y)
        ]



{-
   Percentage Fuzzer

   The percentage fuzzer generates float values between 0.0 and 1.0. It generates zero and one about 10% of the time.
-}


pizzaLeft : Float -> Float -> Float
pizzaLeft eatenPercent totalSlices =
    totalSlices - (eatenPercent * totalSlices)


pizzaLeftTests : Test
pizzaLeftTests =
    describe "pizzaLeft"
        [ fuzz2 percentage (floatRange 0.0 100.0) "returns remaining pizza slices" <|
            \eaten total ->
                pizzaLeft eaten total
                    |> Expect.within (Absolute 0.000000001) (total - (eaten * total))
        ]



{-
   String Fuzzer
   The String fuzzer generates random printable ASCII string values consisting of up to 1000 characters. Since we often
   forget to handle edge cases containing the empty string, the string fuzzer makes sure that it's one of the
   generated values.
-}


stringTests : Test
stringTests =
    describe "The String module"
        [ describe "String.reverse"
            [ test "has no effect on a palindrome" <|
                -- Unit Test - 1
                \_ ->
                    let
                        palindrome : String
                        palindrome =
                            "hannah"
                    in
                    palindrome
                        |> String.reverse
                        |> Expect.equal palindrome
            , test "reverses a known string" <|
                -- Unit Test -2
                \_ ->
                    "ABCDEFG"
                        |> String.reverse
                        |> Expect.equal "GFEDCBA"
            , fuzz string "restores the original string if you run it again" <|
                --Fuzz test
                \randomlyGeneratedString ->
                    randomlyGeneratedString
                        |> String.reverse
                        |> String.reverse
                        |> Expect.equal randomlyGeneratedString
            ]
        ]



{-
   List Fuzzer
   The list fuzzer generates a list of random values of given type.


   list: Fuzzer a -> Fuzzer (List a)

   The list fuzzer returns random lists of varying lengths. It's more likely to return shorter lists, especially an empty
   list.

   Array Fuzzer

   Like list, the array fuzzer generates an array of random values of given type. It's type signature also looks very
   similar to that of list.

   array: Fuzzer a -> Fuzzer (Array a)

-}


listLengthTests : Test
listLengthTests =
    describe "List.length"
        [ fuzz (list int) "never returns a negative value" <|
            \intList ->
                intList
                    |> List.length
                    |> Expect.atLeast 0
        ]


arrayGetTests : Test
arrayGetTests =
    describe "Array.get"
        [ fuzz (array <| intRange -20 20) "returns Nothing for out of range index" <|
            \intArray ->
                let
                    length : Int
                    length =
                        Array.length intArray
                in
                intArray
                    |> Array.get length
                    |> Expect.equal Nothing
        ]



{-
   Tuple Fuzzer
   The tuple fuzzer generates a tuple of random values of given types. The tuple fuzzer takes a tuple of two individual
   fuzzers as the first argument.

   tuple: (Fuzzer a, Fuzzer b) -> Fuzzer (a,b)
-}


addTestsTuple : Test
addTestsTuple =
    describe "add with tuple fuzzer"
        [ fuzz (pair int int) "adds two given integers" <|
            \( num1, num2 ) ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]


listReverseTests : Test
listReverseTests =
    describe "List.reverse"
        [ fuzz (pair (list int) int) "doesn't remove a member of the list" <|
            \( intList, num ) ->
                intList
                    |> List.reverse
                    |> List.member num
                    |> Expect.equal (List.member num intList)
        ]


sumListTests : Test
sumListTests =
    describe "MyList.sum"
        [ fuzz repeatedListFuzzer "should equal the length of list" <|
            \intList ->
                let
                    num : Int
                    num =
                        case intList of
                            Empty ->
                                0

                            Node a _ ->
                                a
                in
                intList
                    |> MyList.sum
                    |> Expect.equal (num * MyList.length intList)
        , fuzz listWithNaturalNumbers "should conform to the formula n*(n+1)/2" <|
            \intList ->
                let
                    num : Int
                    num =
                        case intList of
                            Empty ->
                                0

                            Node a _ ->
                                a
                in
                intList
                    |> MyList.sum
                    |> Expect.equal (num * (num + 1) // 2)
        ]



-- Sum of a list with any repeated element is equal to element * list.length


repeatedListFuzzer : Fuzzer (MyList Int)
repeatedListFuzzer =
    Fuzz.map2 List.repeat (Fuzz.intRange 0 50) (Fuzz.intRange 0 50)
        |> Fuzz.map convertToMyList



-- Sum of a list with n natural numbers is equal to n*(n+1)/2


listWithNaturalNumbers : Fuzzer (MyList Int)
listWithNaturalNumbers =
    Fuzz.map (List.range 1) (Fuzz.intRange 2 50)
        |> Fuzz.map convertToMyList



{-
   # Properties of RippleCarryAdder

   1. If the most significant digits of both inputs are 0, the carry-out digit will always be 0 regardless of what the
   carry-in digit is.

   2. If the most significant digits of both inputs are 1, the carry-out digit will always be 1 regardless of what the
   carry-in digit is.

   3. If the least significant digits of both inputs are 0 and the carry-in digit is also 0, the least significant digit
   of the output will always be 0.

   4. If the least significant digits of both inputs are 1 and the carry-in digit is 0, the least significant digit will
   always be 0.
-}


rippleCarryAdderProperty1 : Test
rippleCarryAdderProperty1 =
    describe "carry-out's relationship with most significant digits"
        [ fuzz3
            (list (intRange 0 1))
            (list (intRange 0 1))
            (intRange 0 1)
            "carry-out is 0 when most significant digits are both 0"
          <|
            \list1 list2 carryIn ->
                let
                    convertToBinary : List Int -> Int
                    convertToBinary digitsList =
                        digitsList
                            -- Take only 3 digits since the msbs are 0
                            |> List.take 3
                            |> numberFromDigits

                    firstInput : Int
                    firstInput =
                        convertToBinary list1

                    secondInput : Int
                    secondInput =
                        convertToBinary list2
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> List.length
                    |> Expect.lessThan 5
        ]


rippleCarryAdderProperty2 : Test
rippleCarryAdderProperty2 =
    describe "carry-out's relationship with msbs, when both are 1"
        [ fuzz3
            (list <| intRange 0 1)
            (list <| intRange 0 1)
            (intRange 0 1)
            "carry-out is 1 when most significant digits are both 1"
          <|
            \list1 list2 carryIn ->
                let
                    convertToBinary : List Int -> Int
                    convertToBinary digitsList =
                        digitsList
                            -- Take only 3 digits since the msbs are 1
                            |> List.take 3
                            |> numberFromDigits

                    firstInput : Int
                    firstInput =
                        1
                            :: list1
                            |> convertToBinary

                    secondInput : Int
                    secondInput =
                        1
                            :: list2
                            |> convertToBinary
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> List.head
                    |> Expect.equal (Just 1)
        ]


rippleCarryAdderProperty3 : Test
rippleCarryAdderProperty3 =
    describe "carry-in's relationship with least significant digits - property 3"
        [ fuzz3
            (list <| intRange 0 1)
            (list <| intRange 0 1)
            (constant 0)
            """
            the least significant digit of the output is 0 when the carry-in is 0 and the least
            significant digits of both inputs are 0
            """
          <|
            \list1 list2 carryIn ->
                let
                    firstInput : Int
                    firstInput =
                        convertToBinary list1

                    secondInput : Int
                    secondInput =
                        convertToBinary list2

                    convertToBinary : List Int -> Int
                    convertToBinary digitsList =
                        digitsList
                            |> List.take 4
                            |> setLastDigitToZero
                            |> numberFromDigits

                    setLastDigitToZero : List Int -> List Int
                    setLastDigitToZero digitsList =
                        List.take 3 digitsList ++ [ 0 ]

                    isLastDigitZero : List Int -> Bool
                    isLastDigitZero digitsList =
                        digitsList
                            |> List.reverse
                            |> List.head
                            |> Maybe.withDefault 0
                            |> (==) 0
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> isLastDigitZero
                    |> Expect.equal True
        ]


rippleCarryAdderProperty4 : Test
rippleCarryAdderProperty4 =
    describe "carry-in's relationship with least significant digits - property 4"
        [ fuzz3
            (list <| intRange 0 1)
            (list <| intRange 0 1)
            (constant 0)
            """
            the least significant digit of the output is 0 when the carry-in is 0 and the least
            significant digits of both inputs are 1
            """
          <|
            \list1 list2 carryIn ->
                let
                    firstInput : Int
                    firstInput =
                        convertToBinary list1

                    secondInput : Int
                    secondInput =
                        convertToBinary list2

                    convertToBinary : List Int -> Int
                    convertToBinary digitsList =
                        digitsList
                            |> List.take 4
                            |> setLastDigitToOne
                            |> numberFromDigits

                    setLastDigitToOne : List Int -> List Int
                    setLastDigitToOne digitsList =
                        List.take 3 digitsList ++ [ 1 ]

                    isLastDigitZero : List Int -> Bool
                    isLastDigitZero digitsList =
                        digitsList
                            |> List.reverse
                            |> List.head
                            |> Maybe.withDefault 0
                            |> (==) 0
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> isLastDigitZero
                    |> Expect.equal True
        ]
