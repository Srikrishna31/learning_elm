port module PortExamples exposing (..)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Json.Decode exposing (Error(..), Value, decodeValue, string)


type alias Model =
    { dataFromJS : String
    , dataToJS : ComplexData
    , jsonError : Maybe Error
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        , viewDataFromJSorError model
        ]


type alias ComplexData =
    { posts : List Post
    , comments : List Comment
    , profile : Profile
    }


type alias Post =
    { id : Int
    , title : String
    , author : Author
    }


type alias Author =
    { name : String
    , url : String
    }


type alias Comment =
    { id : Int
    , body : String
    , postId : Int
    }


type alias Profile =
    { name : String }


viewDataFromJSorError : Model -> Html Msg
viewDataFromJSorError model =
    case model.jsonError of
        Just error ->
            viewError error

        Nothing ->
            viewDataFromJS model.dataFromJS


viewError : Error -> Html Msg
viewError err =
    let
        errorMessage : String
        errorMessage =
            case err of
                Failure message _ ->
                    message

                _ ->
                    "Error: Invalid JSON"
    in
    div []
        [ h3 [] [ text "Couldn't receive data from JavaScript" ]
        , text <| "Error: " ++ errorMessage
        ]


viewDataFromJS : String -> Html Msg
viewDataFromJS json =
    div []
        [ br [] []
        , strong [] [ text "Data received from JavaScript: " ]
        , text json
        ]


type Msg
    = SendDataToJS
    | ReceivedDataFromJS Value



{-
   decodeString vs decodeValue
   We used decodeValue in below function, whereas we used decodeString earlier to decode data from an HTTP server. This
   is because, the data coming from JavaScript is already a valid JSON. An HTTP server on the other hand sends a raw string
   which must be parsed first to make sure that it's a valid JSON. That's why, decodeString had to be used. The decodeValue
   skips the parsing altogether and focuses on transforming a valid JSON into an Elm value.

    decodeString: Decoder a -> String -> Result Error a
    decodeValue: Decoder a -> Value -> Result Error a
-}


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData model.dataToJS )

        ReceivedDataFromJS data ->
            case decodeValue string data of
                Ok info ->
                    ( { model | dataFromJS = info }, Cmd.none )

                Err error ->
                    ( { model | jsonError = Just error }, Cmd.none )



{-
   The `port` keyword automatically creates a function for us. All it expects is the function's name and type. The
   function generated by port takes only one argument. We don't need to create a body for this function. port automatically
   does that for us by looking at the function's type. THe function generated by port must return Cmd msg and nothing else.

   Unlike all other commands, the command generated by a port function doesn't send a message back to the update function
   once the operation is complete. A command that doesn't send any messages back to the app always has the type Cmd msg.

   The syntax for calling a port function is identical to that of a regular function.

   For sending complex json data, it's enough to define it as types in ELm, and then hand it over to the port. Elm runtime
   takes care of converting the data into JSON.
-}


port sendData : ComplexData -> Cmd msg



{-
   The incoming port function also takes only one argument. The argument here is a function that takes the model and
   returns a message.
   The incoming port function always returns a subscription, whereas the outgoing port function returns a command.
-}


port receiveData : (Value -> msg) -> Sub msg


init : () -> ( Model, Cmd Msg )
init _ =
    ( initialModel, Cmd.none )


initialModel : Model
initialModel =
    { dataFromJS = ""
    , jsonError = Nothing
    , dataToJS = initialComplexData
    }


initialComplexData : ComplexData
initialComplexData =
    let
        post1 =
            Author "typicode" "https://github.com/typicode"
                |> Post 1 "json-server"

        post2 =
            Author "indexzero" "https://github.com/indexzero"
                |> Post 2 "http-server"
    in
    { posts = [ post1, post2 ]
    , comments = [ Comment 1 "some comment" 1 ]
    , profile = { name = "typicode" }
    }



{-
   Interacting with JavaScript code from an Elm app is very similar to how we interact with an HTTP server. Therefore, to
   keep things simple, Elm prefers to stick with JSON when sending and receiving data from JavaScript as well.
-}


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveData ReceivedDataFromJS
